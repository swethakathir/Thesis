property read_hit;
disable iff: !i_Reset_n;
assume:
at t: i_Valid && !o_Valid;
at t: i_Read_Write_n && Valid_Array[i_Index];
at t: Tag_Array[i_Index] == i_Tag;
at t: State == STATE_READY;
prove:
at t: o_Ready;
at t+1: if(prev(i_BlockOffset) == 0)
          o_Data == prev(databank/mem[i_Index]); 
         elseif(prev(i_BlockOffset) == 1)
          o_Data == prev(databank1/mem[i_Index]); 
        elseif(prev(i_BlockOffset) == 2)
          o_Data == prev(databank2/mem[i_Index]); 
        elseif(prev(i_BlockOffset) == 3)
          o_Data == prev(databank3/mem[i_Index]); 
        else
          o_Data == prev(i_MEM_Data); 
        endif;
at t+1: o_Valid;
at t+1: !o_MEM_Valid;
at t+1: o_MEM_Data == prev(o_MEM_Data);  
at t+1:  o_MEM_Read_Write_n == prev( o_MEM_Read_Write_n); 
at t+1: o_MEM_Address == prev(o_MEM_Address);
end property;


property write_hit;
disable iff: !i_Reset_n;
assume:
at t: i_Valid && !o_Valid;
at t: !i_Read_Write_n && Valid_Array[i_Index];
at t: Tag_Array[i_Index] == i_Tag;
at t: State == STATE_READY;
prove:
at t: o_Ready;
at t+1: if(prev(i_BlockOffset) == 0)
          databank/mem[prev(i_Index)] == prev(i_Write_Data); 
        endif;
at t+1: if(prev(i_BlockOffset) == 1)
          databank1/mem[prev(i_Index)] == prev(i_Write_Data); 
        endif;
at t+1: if(prev(i_BlockOffset) == 2)
          databank2/mem[prev(i_Index)] == prev(i_Write_Data); 
        endif;
at t+1: if(prev(i_BlockOffset) == 3)
          databank3/mem[prev(i_Index)] == prev(i_Write_Data);   // cant verify output o_Data because r_i_BlockOffset is not assigned in case of writehit.
        endif;
at t+1: o_Valid;
at t+1: !o_MEM_Valid;
at t+1: o_MEM_Data == prev(o_MEM_Data); 
at t+1:  o_MEM_Read_Write_n == prev( o_MEM_Read_Write_n); 
at t+1: o_MEM_Address == prev(o_MEM_Address);
end property;


property read_miss;
disable iff: !i_Reset_n;
freeze:
	index = i_Index@t,
	block_offset = i_BlockOffset@t,
	o_mem_data = o_MEM_Data@t,
	mem_data_0 = i_MEM_Data@t+1,
	mem_data_1 = i_MEM_Data@t+2,
	mem_data_2 = i_MEM_Data@t+3,
	mem_data_3 = i_MEM_Data@t+4;
assume:
at t: i_Valid && !o_Valid;
at t: !Valid_Array[i_Index] || Tag_Array[i_Index] != i_Tag;
at t: !Valid_Array[i_Index] || !Dirty_Array[i_Index];
at t: State == STATE_READY;
at t: i_Read_Write_n;
during[t+1,t+4]: i_MEM_Valid;
during[t+1,t+3]: !i_MEM_Last;
at t+4: i_MEM_Last;
prove:
at t+1: o_MEM_Valid;
at t+1: o_MEM_Read_Write_n;
at t+3: databank/mem[index] == mem_data_0;
at t+4: databank1/mem[index] == mem_data_1; //databank/mem[index] == mem_data_1;// 
at t+5: databank2/mem[index] == mem_data_2; //bank2writedata == prev(i_MEM_Data);
at t+6: databank3/mem[index] == mem_data_3; //bank3writedata == prev(i_MEM_Data);
at t+5: !o_MEM_Valid;
at t+6: o_Valid;
at t+7: o_Ready;
at t+6: if(block_offset == 0)
          o_Data == databank/mem[index]; 
        endif;
at t+6: if(block_offset == 1)
          o_Data == databank1/mem[index]; 
        endif;
at t+6: if(block_offset == 2)
          o_Data == databank2/mem[index]; 
        endif;
at t+6: if(block_offset == 3)
          o_Data == databank3/mem[index]; 
        endif;
at t+6: if(prev(i_BlockOffset) > 3)
          o_Data == prev(i_MEM_Data); 
        endif;
at t+6: o_MEM_Data == o_mem_data;           //Need to verify o_MEM_Address, also check o_MEM_Valid
end property;



property read_miss_dirty_set;
disable iff: !i_Reset_n;
freeze:
	index = i_Index@t,
	data0 = databank/mem[i_Index]@t,
	data1 = databank1/mem[index]@t+1,
	data2 = databank2/mem[index]@t+2,
	data3 = databank3/mem[index]@t+3,
	block_offset = i_BlockOffset@t,
	mem_data_0 = i_MEM_Data@t+5,
	mem_data_1 = i_MEM_Data@t+6,
	mem_data_2 = i_MEM_Data@t+7,
	mem_data_3 = i_MEM_Data@t+8;
assume:
at t: i_Valid && !o_Valid;
at t: Tag_Array[i_Index] != i_Tag;
at t: Valid_Array[i_Index] && Dirty_Array[i_Index];
at t: State == STATE_READY;
at t: i_Read_Write_n;
during[t+1,t+4]: i_MEM_Data_Read;
during[t+1,t+3]: !i_MEM_Last;
at t+4: i_MEM_Last;
during[t+5,t+8]:i_MEM_Valid;
during[t+5,t+7]: !i_MEM_Last;
at t+8: i_MEM_Last;
prove:
at t+1: o_MEM_Valid;
at t+2: !o_MEM_Read_Write_n;
at t+2: o_MEM_Data == data0; //prev(bank0readdata);
at t+3: o_MEM_Data == data1; //prev(bank1readdata);
at t+4: o_MEM_Data == data2;
at t+5: o_MEM_Data == data3; 
//at t+5: !Dirty_Array[index];
at t+5: o_MEM_Read_Write_n;
at t+7: databank/mem[index] == mem_data_0;
at t+8: databank1/mem[index] == mem_data_1;
at t+9: databank2/mem[index] == mem_data_2;
at t+10: databank3/mem[index] == mem_data_3;
at t+9: !Dirty_Array[index];
at t+9: !o_MEM_Valid;
at t+10: o_Valid;
at t+11: o_Ready;
at t+10: if(block_offset == 0)
          o_Data == databank/mem[index]; 
        endif;
at t+10: if(block_offset == 1)
          o_Data == databank1/mem[index]; 
        endif;
at t+10: if(block_offset == 2)
          o_Data == databank2/mem[index]; 
        endif;
at t+10: if(block_offset == 3)
          o_Data == databank3/mem[index]; 
        endif;
at t+10: if(prev(i_BlockOffset) > 3)
          o_Data == prev(i_MEM_Data); 
        endif;                                      //Need to verify o_MEM_Address, o_Mem_Read_Write_n is assigned two times in state_writeout.which
                                                    //one should be checked? also for o_Mem_Valid?
end property;


property write_miss;
disable iff: !i_Reset_n;
freeze:
	index = i_Index@t,
	i_write_data = i_Write_Data@t,
	block_offset = i_BlockOffset@t,
	o_mem_data = o_MEM_Data@t,
	mem_data_0 = i_MEM_Data@t+1,
	mem_data_1 = i_MEM_Data@t+2,
	mem_data_2 = i_MEM_Data@t+3,
	mem_data_3 = i_MEM_Data@t+4;
assume:
at t: i_Valid && !o_Valid;
at t: !Valid_Array[i_Index] || Tag_Array[i_Index] != i_Tag;
at t: !Valid_Array[i_Index] || !Dirty_Array[i_Index];
at t: State == STATE_READY;
at t: !i_Read_Write_n;
during[t+1,t+4]: i_MEM_Valid;
during[t+1,t+3]: !i_MEM_Last;
at t+4: i_MEM_Last;
prove:
at t+1: o_MEM_Valid;
at t+1: o_MEM_Read_Write_n;
at t+3: if (block_offset == 0)
          databank/mem[index] == i_write_data;
        else
          databank/mem[index] == mem_data_0;
        endif;
at t+4: if (block_offset == 1)
          databank1/mem[index] == i_write_data;
        else
          databank1/mem[index] == mem_data_1;
        endif;
at t+5: if (block_offset == 2)
          databank2/mem[index] == i_write_data;
        else
          databank2/mem[index] == mem_data_2;
        endif;
at t+6: if (block_offset == 3)
          databank3/mem[index] == i_write_data;
        else
          databank3/mem[index] == mem_data_3;   
        endif;
at t+5: Dirty_Array[index];
at t+5: !o_MEM_Valid;
at t+6: o_Valid;
at t+7: o_Ready;
at t+7: o_MEM_Data == o_mem_data;              //Need to verify o_Mem_address,o_data
end property;


property write_miss_dirty_set;
disable iff: !i_Reset_n;
freeze:
	index = i_Index@t,
  data0 = databank/mem[i_Index]@t,
	data1 = databank1/mem[index]@t+1,
	data2 = databank2/mem[index]@t+2,
	data3 = databank3/mem[index]@t+3,
	block_offset = i_BlockOffset@t,
	i_write_data = i_Write_Data@t,
	mem_data_0 = i_MEM_Data@t+5,
	mem_data_1 = i_MEM_Data@t+6,
	mem_data_2 = i_MEM_Data@t+7,
	mem_data_3 = i_MEM_Data@t+8;
assume:
at t: i_Valid && !o_Valid;
at t: Tag_Array[i_Index] != i_Tag;
at t: Valid_Array[i_Index] && Dirty_Array[i_Index];
at t: State == STATE_READY;
at t: !i_Read_Write_n;
during[t+1,t+4]: i_MEM_Data_Read;
during[t+1,t+3]: !i_MEM_Last;
at t+4: i_MEM_Last;
during[t+5,t+8]:i_MEM_Valid;
during[t+5,t+7]: !i_MEM_Last;
at t+8: i_MEM_Last;
prove:
at t+1: o_MEM_Valid;
at t+2: !o_MEM_Read_Write_n;
at t+2: o_MEM_Data == data0;
at t+3: o_MEM_Data == data1;
at t+4: o_MEM_Data == data2;
at t+5: o_MEM_Data == data3; 
at t+5: !Dirty_Array[index];
at t+5: o_MEM_Read_Write_n;
at t+7: if (block_offset == 0)
          databank/mem[index] == i_write_data;
        else
          databank/mem[index] == mem_data_0;
        endif;
at t+8: if (block_offset == 1)
          databank1/mem[index] == i_write_data;
        else
          databank1/mem[index] == mem_data_1;
        endif;
at t+9: if (block_offset == 2)
          databank2/mem[index] == i_write_data;
        else
          databank2/mem[index] == mem_data_2;
        endif;
at t+10: if (block_offset == 3)
          databank3/mem[index] == i_write_data;
        else
          databank3/mem[index] == mem_data_3;   //Need to verify o_data,o_Mem_address
        endif;
at t+9: Dirty_Array[index];
at t+9: !o_MEM_Valid;
at t+10: o_Valid;
at t+11: o_Ready;
end property;
